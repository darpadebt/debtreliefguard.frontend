<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Loading… | DebtReliefGuard Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Loading blog post…" />
  <meta name="robots" content="index,follow" />

  <!-- Keep any theme CSS includes you already load globally via layout/_headers -->
  <style>
    /* minimal guard styles; your existing theme CSS will still apply */
    #post-body { min-height: 200px; }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <!--
    Structure matches prior expectations:
    - #post-title: gets title text
    - #post-meta:  optional author/date rendering (if present in blogs.json)
    - #post-body:  receives injected HTML from the dated content_url
  -->
  <header id="post-header">
    <h1 id="post-title">Loading…</h1>
    <div id="post-meta" class="hidden"></div>
  </header>

  <article id="post-body" aria-busy="true">Loading content…</article>

  <script>
    (function () {
      /** Telemetry helper – keeps your existing logging if present. */
      function logTelemetry(event, data) {
        try {
          if (window.GFSR && typeof window.GFSR.log === 'function') {
            window.GFSR.log(event, data);
          }
        } catch (_) {}
      }

      /** Resolve current slug from URL: /blog/<slug> or /blog/<slug>.html */
      function getSlugFromPath() {
        const path = location.pathname.replace(/\/+$/, ''); // trim trailing slash
        const last = path.split('/').pop() || '';
        return last.replace(/\.html$/i, ''); // strip .html if present
      }

      /** Join base + path safely. */
      function joinUrl(base, path) {
        try {
          return new URL(path, base).toString();
        } catch {
          // If base missing protocol, assume same origin
          if (path.startsWith('http')) return path;
          if (path.startsWith('/')) return path;
          return (base.replace(/\/+$/, '') + '/' + path.replace(/^\/+/, ''));
        }
      }

      /** Absolutize URLs for href/src and common attributes using a base. */
      function absolutizeUrls(root, baseUrl) {
        const ATTRS = ['href', 'src', 'srcset', 'data-src'];
        const all = root.querySelectorAll('*');
        all.forEach((el) => {
          ATTRS.forEach((a) => {
            if (!el.hasAttribute(a)) return;
            const val = el.getAttribute(a) || '';
            if (!val) return;
            // Handle srcset specially (may contain multiple URLs)
            if (a === 'srcset' && /,|\s\d/.test(val)) {
              const items = val.split(',').map(s => s.trim()).filter(Boolean);
              const fixed = items.map(item => {
                const m = item.match(/^(\S+)(\s+.+)?$/);
                if (!m) return item;
                const abs = joinUrl(baseUrl, m[1]);
                return abs + (m[2] || '');
              });
              el.setAttribute('srcset', fixed.join(', '));
              return;
            }
            // Skip data:, mailto:, tel:
            if (/^(data:|mailto:|tel:)/i.test(val)) return;
            // Make absolute
            const abs = joinUrl(baseUrl, val);
            el.setAttribute(a, abs);
          });
        });
        return root;
      }

      /**
       * Parse fetched HTML and return a container with just the meaningful content.
       * Preference: <article> → <main> → <body> → (fallback) entire parsed contents.
       * We lift only the children of the chosen scope into a clean div.
       */
      function sanitizeAndScopeToContent(htmlText, baseUrl) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlText, 'text/html');

        // Update <title> and <meta name="description"> in our shell (optional)
        try {
          const incomingTitle = doc.querySelector('title')?.textContent?.trim();
          if (incomingTitle) document.title = incomingTitle;
          const incomingDesc = doc.querySelector('meta[name="description"]')?.getAttribute('content');
          if (incomingDesc) {
            let meta = document.querySelector('meta[name="description"]');
            if (!meta) {
              meta = document.createElement('meta');
              meta.setAttribute('name', 'description');
              document.head.appendChild(meta);
            }
            meta.setAttribute('content', incomingDesc);
          }
        } catch (_) {}

        // Choose the best scope to render
        const scope =
          doc.querySelector('article') ||
          doc.querySelector('main') ||
          doc.body ||
          doc.documentElement;

        // Clone chosen scope into a temp container and absolutize resources
        const tmp = document.createElement('div');
        // Move (not clone) children so we don’t duplicate scripts/styles badly
        while (scope.firstChild) tmp.appendChild(scope.firstChild);

        absolutizeUrls(tmp, baseUrl);

        // Now lift only the scope's children into a clean container for injection
        const container = document.createElement('div');
        while (tmp.firstChild) container.appendChild(tmp.firstChild);
        return container;
      }

      /** Render meta line (author, date) if available. */
      function setPostMeta(post) {
        const meta = document.getElementById('post-meta');
        if (!meta) return;
        const bits = [];
        if (post.author) bits.push(post.author);
        if (post.date_published) bits.push(new Date(post.date_published).toLocaleDateString());
        meta.textContent = bits.join(' • ');
        if (bits.length) meta.classList.remove('hidden');
      }

      async function load() {
        const slug = getSlugFromPath();
        const listUrl = '/blogs.json';

        // 1) Fetch blogs.json
        const listRes = await fetch(listUrl, { credentials: 'same-origin' });
        if (!listRes.ok) throw new Error('Failed to load blogs.json: ' + listRes.status);
        const posts = await listRes.json();

        // 2) Find matching post
        const post = (Array.isArray(posts) ? posts : []).find(p => (p.slug || '').toLowerCase() === slug.toLowerCase());
        if (!post) throw new Error('Post not found in blogs.json for slug: ' + slug);

        // 3) Build absolute content URL (dated HTML). If folder path, fall back to index.html
        let contentURL = post.content_url || '';
        if (!contentURL) throw new Error('Missing content_url for slug: ' + slug);
        // If content_url ends with '/', resolve to index.html
        if (/\/$/.test(contentURL)) contentURL = contentURL + 'index.html';

        const absContentURL = joinUrl(location.origin, contentURL);

        // 4) Update shell title/meta from blogs.json (can be overridden by fetched doc)
        if (post.title) document.getElementById('post-title').textContent = post.title;
        setPostMeta(post);
        if (post.excerpt) {
          let meta = document.querySelector('meta[name="description"]');
          if (!meta) {
            meta = document.createElement('meta');
            meta.setAttribute('name', 'description');
            document.head.appendChild(meta);
          }
          meta.setAttribute('content', post.excerpt);
        }

        // 5) Fetch the dated HTML file
        const res = await fetch(absContentURL, { credentials: 'same-origin' });
        if (!res.ok) throw new Error('Failed to fetch content_url: ' + res.status + ' ' + absContentURL);
        const htmlText = await res.text();

        // 6) Parse & inject ONLY the meaningful content (article/main/body children)
        const container = sanitizeAndScopeToContent(htmlText, absContentURL);
        const bodyTarget = document.getElementById('post-body');
        if (!bodyTarget) throw new Error('#post-body not found');
        bodyTarget.innerHTML = '';
        while (container.firstChild) bodyTarget.appendChild(container.firstChild);
        bodyTarget.removeAttribute('aria-busy');

        // 7) Telemetry hook (unchanged in spirit)
        logTelemetry('blog_open', {
          slug,
          content_url: contentURL,
          ts: Date.now()
        });
      }

      load().catch(err => {
        console.error(err);
        const bodyTarget = document.getElementById('post-body');
        if (bodyTarget) {
          bodyTarget.removeAttribute('aria-busy');
          bodyTarget.innerHTML = '<p>Sorry, we couldn\'t load this article right now.</p>';
        }
        logTelemetry('blog_open_error', {
          message: String(err && err.message || err),
          ts: Date.now()
        });
      });
    })();
  </script>
</body>
</html>
